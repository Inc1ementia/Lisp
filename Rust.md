# Язык программирования Rust

## Особенности Rust

Rust позиционируется как *компилируемый системный мультипарадигмальный язык высокого уровня*.

- **Компилируемый** язык означает, что готовая программа — это отдельный файл, который можно запустить на любом компьютере с нужной операционной системой.
- **Системный** — это когда на языке пишут программы для работы системы в целом.
- **Мультипарадигмальный** значит, что в языке сочетаются несколько парадигм программирования. В случае Rust это ООП, процедурное и функциональное программирование. Причём, ООП в Rust пришло из C++, а функциональное — из Haskell.

В Rust поддерживаются функицональное, параллельное, процедурное и объектно-ориентированное программирование, т.е. почти весь спектр реально используемых в прикладном программировании парадигм.

Ключевые приоритеты языка: *безопасность*, *скорость* и *параллелизм*. Rust пригоден для системного программирования, в частности, он рассматривается как перспективный язык для разработки ядер операционных систем. Rust сопоставим по скорости и возможностям с C++/C, однако даёт большую безопасность при работе с памятью, что обеспечивается встроенными в язык механизмами контроля ссылок. Производительности программ на Rust способствует использование «абстракций с нулевой стоимостью».

## История языка

Разработкой языка занялся в свободное время сотрудник Mozilla Грэйдон Хор 14 лет назад, в 2006. Три года он действовал самостоятельно, пока в 2009-м к работе официально не подключилась Mozilla. В 2010 Rust был представлен официально.

Первый альфа-релиз языка состоялся в 2012. На Rust был разработан Servo, движок для веб-браузеров. В 2013 к работе над Servo присоединился Samsung, в результате чего код Servo был портирован на ARM-архитектуру.

Rust 1.0 вышел в 2015. В свой первый год Rust взял бронзу в голосовании «Любимый язык программирования» на портале Stack Overflow. Все последующие годы Rust занимает только первое место.

## Синтаксис и код

За основу синтаксиса в Rust взят синтаксис из C и C++. Например, классический «Привет, мир!» на Rust выглядит так:

```rust
fn main() {
	println!("Hello, world!");
}
```

Пример сложнее - функция расчёта факториала:

```rust
fn fac(n: int) -> int {
	let result = 1, i = 1;
	while i <= n {
		result *= i;
		i += 1;
	}
	ret result;
}
```

Однако есть свои особенности:

- переменные менять нельзя, а если нужно — при объявлении указывают ключевое слово mutable;
- все команды внутри условных операторов, циклов и других блочных конструкций обязательно брать в фигурные скобки, даже если там будет всего одна команда;
- аргументы у условных операторов, например if или while, в скобки брать не нужно;
- при объявлении переменной можно использовать условный оператор:

```rust
let x = if new_game() { 4 }
		else if reload() { 3 }
		else { 0 }
```

Ещё в Rust есть сравнение переменной с образцом. В зависимости от того, с каким образцом совпало значение переменной, выполнится та или иная функция:

```rust
alt my_number {
	0 { std::io::println("Ноль"); }
	1 | 2 { std::io::println("Один или два"); }
	3 to 10 { std::io::println("От трёх до десяти"); }
	_ { std::io::println("Что-то другое…"); }
}
```

В языке присутствую встроенные средства отладки программ:

- Ключевое слово **fail** завершает текущий процесс
- Ключевое слово **log** выводит любое выражение языка в лог (например, в stderr)
- Ключевое слово **assert** проверяет выражение, и если оно ложно, завершает текущий процесс
- Ключевое слово **note** позволяет вывести дополнительную инфорацию в случае аварийного завершения процесса.

Rust, подобно Go, поддерживает **структурную типизацию** (хотя, по утверждению авторов, языки развивались независимо, так что это влияние их общих предшественников — Alef, Limbo и т.д.).

Структуры в Rust называются **записи** (record). Также имеются *кортежи* — это те же записи, но с безымянными полями. Элементы кортежа, в отличие от элементов записи, не могут быть изменяемыми.

Имеются вектора — в чем-то подобные обычным массивам, а в чем-то — типу std::vector из stl. При инициализации списком используются квадратные скобки, а не фигурные как в С/С++:

```rust
let myvec = [1, 2, 3, 4];
```

Вектор, тем ни менее — динамическая структура данных, в частности, вектора поддерживают конкатенацию:

```rust
let v: mutable [int] = [1, 2, 3];
v += [4, 5, 6];
```

Кроме обычных указателей из C, в Rust поддерживаются специальные *«умные» указатели* со встроенным подсчетом ссылок — **разделяемые** (Shared boxes) и **уникальные указатели** (Unique boxes), которые имеют свой синтаксис: @ для разделяемых и ~ для уникальных. Для уникальных указателей вместо копирования существует специальная операция — перемещение:

```rust
let x = ~10;
let y <- x;
```

Ключевое слово **lambda** используется для объявления вложенной функции или функционального типа данных:

```rust
fn make_plus_function(x: int) -> lambda(int) -> int {
	lambda(y: int) -> int { x + y }
}
let plus_two = make_plus_function(2);
assert plus_two(3) == 5;
```

В этом примере мы имеем функцию make_plus_function, принимающую один аргумент «x» типа int и возвращающую функцию типа «int->int» (здесь lambda — ключевое слово). В теле функции описывается эта самая функция.

Ключевое слово **block** используется для объявления функционального типа — аргумента функции, в качестве которого можно подставить нечто, похожее на блок обычного кода:

```rust
fn map_int(f: block(int) -> int, vec: [int]) -> [int] {
	let result = [];
	for i in vec { result += [f(i)]; }
	ret result;
} 
map_int({|x| x + 1 }, [1, 2, 3]);
```

Здесь мы имеем функцию, на вход которой подается блок — по сути лямбда-функция типа «int->int», и вектор типа int (о синтаксисе векторов далее). Сам «блок» в вызывающем коде записыавется с помощью несколько необычного синтаксиса {|x| x + 1 }.

Частичное применение — это создание функции на основе другой функции с большим количеством аргументов путем указания значений некоторых аргументов этой другой функции. Для этого используется ключевое слово **bind** и символ-заполнитель "_":

```rust
let daynum = bind std::vec::position(_, ["mo", "tu", "we", "do", "fr", "sa", "su"])
```

Чистые (pure) функции — это функции, не имеющие побочных эффектов (в том числе не вызывающие никаких других функций, кроме чистых). Такие функции выделяются ключевым словом **pure**:

```rust
pure fn lt_42(x: int) -> bool {
	ret (x < 42);
}
```

## Плюсы и минусы языка

Преимущества:

- без проблем работает на Unix и Mac;
- есть абстракции, которые существенно упрощают регулирование памяти вручную;
- надёжная система взаимодействия с памятью, исключающая ошибки сегментации;
- высокая скорость работы программ;
- возможность написать код в ООП-стиле: с классами и объектами (но есть ограничения);
- автоматическое представление способов исправить ошибки при компиляции;
- компилятор содержит сборщик и менеджер пакетов, инструменты для тестирования и создания документации;
- в безопасном коде нет возможности применять указатели (только ссылки на 100% реальные объекты);
- поддержка многопоточности;
- доступное описание ошибок в шаблонах.

Недостатки:

- Компилятор слишком строго фиксирует вызовы к памяти;
- Нет типичных для ООП-стиля наследования и классов;
- Избыточная документация, которая иногда противоречит сама себе;
- Меняющийся от версии к версии синтаксис.

## Использование Rust

Чаще всего Rust используют в тех проектах, где нужна стабильность и надёжность при высокой нагрузке и общее быстродействие программы.

Например:

- программирование клиентских приложений и веб-серверов;
- blockchain;
- создание собственных ОС;
- написание программ и приложений по мониторингу систем и серверов;
- разработка ПО общего назначения;
- создание инфраструктуры;
- написание движков для браузеров и игр.

Вот самые известные проекты, где Rust был основным языком программирования:

- Dropbox — серверная часть, которая отвечает за синхронизацию.
- Coursera — большая часть фронт- и бэкенда написана на Rust.
- Mozilla: Firefox и sccache (распределённый кэш для компилятора).
- OpenDNS — сервис для использования общедоступных DNS-сервисов.
- Servo — браузерный движок с многопоточностью.
- Twitter — использует Rust для высоконагруженной части сервиса.

